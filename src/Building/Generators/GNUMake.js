const { selectCompiler } = require("../../Helper");
const { TargetType } = require("../../General/TargetType.js");

const path = require("path");
const fs = require("fs");

class GNUMakeGenerator
{
	constructor()
	{
		this.workingDirectory = "";

		this.cppCompilerCmd = "g++";
		this.cCompilerCmd = "gcc";
		this.makeProgram = "make";
		this.archiveProgram = "ar";
		this.fileTargetOptions = [
				"$(PROJECT_INCLUDE_DIRECTORIES)",
				"$(PROJECT_LINKER_DIRECTORIES)"
			].join(" ");
		this.projectTargetOptions = [
				"$(PROJECT_LINKED_LIBRARIES)"
			].join(" ");
	}

	
	/**
	 * Generates GNU Makefile build info for specified target.
	 * @param {object} target - the target to generate.
	 */
	generate(target)
	{
		if (typeof target === "object")
		{
			// If not set:
			target.type = target.type || TargetType.Application;

			switch(target.type)
			{
			case TargetType.Application:
				return this.generateApplicationMakefile(target);

			case TargetType.StaticLibrary:
				return this.generateStaticLibraryMakefile(target);

			default:
				// TODO: add support for complex file target setups.
				throw `invalid target type: "${target.type || "unknown"}"`;
			}
		}
		throw "invalid target, valid object required";
	}


	prepareDefaultMakefile(project)
	{
		let content = "# Generated by cpp-build\n";
		content += `CPP=${this.cppCompilerCmd}\n`;
		content += `CC=${this.cCompilerCmd}\n`;

		// Include directories:
		content += "PROJECT_INCLUDE_DIRECTORIES="
		if (Array.isArray(project.includeDirectories))
		{
			const fmt = (dir) => GNUMakeGenerator.formatIncludeDirectory(project.__scriptDirectory, dir);
			content += project.includeDirectories.map( fmt ).join(" ");
		}
		content += "\n";
		
		// Linker directories:
		content += "PROJECT_LINKER_DIRECTORIES="
		if (Array.isArray(project.linkerDirectories))
		{
			const fmt = (dir) => GNUMakeGenerator.formatLinkerDirectory(project.__scriptDirectory, dir);
			content += project.linkerDirectories.map( fmt ).join(" ");
		}
		content += "\n";

		// Linked libraries:
		content += "PROJECT_LINKED_LIBRARIES="
		if (Array.isArray(project.linkedLibraries))
		{
			const fmt = (dir) => GNUMakeGenerator.formatLinkedLibrary(dir);
			content += project.linkedLibraries.map( fmt ).join(" ");
		}
		content += "\n";

		return content;
	}

	generateApplicationMakefile(target)
	{
		const makefilePrefix = this.prepareDefaultMakefile(target);

		let substepsContent = "";

		const buildAllStep = {
			header: "all:",
			command: `\t$(CPP) -o ${target.name||"a"} ${this.projectTargetOptions}`
		};

		for(const file of target.files)
		{
			const generated = this.generateFileMakefileStep(file);
			if (generated)
			{
				buildAllStep.header += " " + generated.stepName;
				buildAllStep.command += " " + generated.stepName + ".o";
				substepsContent += `\n${generated.stepName}:\n\t${generated.content}`;
			}
		}

		return {
				type: "makefile",
				content: `${makefilePrefix}\n\n${buildAllStep.header}\n${buildAllStep.command}\n\n${substepsContent}`
			};
	}

	generateStaticLibraryMakefile(target)
	{
		throw "not supported";
	}

	generateFileMakefileStep(target)
	{
		let compilerString = null;
			
		{
			const compilerType = selectCompiler(target);

			if (compilerType == "cpp")
				compilerString = "$(CPP)";
			else if (compilerType == "c")
				compilerString = "$(CC)";
		}

		// Do not generate build steps for unsupported file types:
		if (!compilerString)
		{
			return null;
		}
		
		const targetAbsolutePath = path.resolve(this.workingDirectory, target);
		const targetBaseName = path.basename(target);

		// Create build step
		// TODO: add include folders, etc.
		return { 
				type: "step",
				stepName: targetBaseName,
				content: `${compilerString} -o ${targetBaseName}.o -c ${targetAbsolutePath} ${this.fileTargetOptions}`
			};
	}


	static formatIncludeDirectory(projectDir, inc)
	{
		const resolvedDirectory = path.resolve(projectDir, inc);
		return `"-I${resolvedDirectory}"`;
	}


	static formatLinkerDirectory(projectDir, link)
	{
		const resolvedDirectory = path.resolve(projectDir, link);
		return `"-L${resolvedDirectory}"`;
	}


	static formatLinkedLibrary(lib)
	{
		return `"-l${lib}"`;
	}
}

module.exports = {
	GNUMakeGenerator
}