const { selectCompiler } = require("../../Helper");

const path = require("path");
const fs = require("fs");

class GNUMakeGenerator
{
	constructor()
	{
		this.workingDirectory = "";

		this.cppCompilerCmd = "g++";
		this.cCompilerCmd = "gcc";
		this.makeProgram = "make";
		this.archiveProgram = "ar";
		this.fileTargetOptions = [
				"$(PROJECT_INCLUDE_DIRECTORIES)",
				"$(PROJECT_LINKER_DIRECTORIES)"
			].join(" ");
		this.projectTargetOptions = [
				"$(PROJECT_LINKED_LIBRARIES)"
			].join(" ");
	}

	static formatIncludeDirectory(projectDir, inc)
	{
		const resolvedDirectory = path.resolve(projectDir, inc);
		return `"-I${resolvedDirectory}"`;
	}

	static formatLinkerDirectory(projectDir, link)
	{
		const resolvedDirectory = path.resolve(projectDir, link);
		return `"-L${resolvedDirectory}"`;
	}

	static formatLinkedLibrary(lib)
	{
		return `"-l${lib}"`;
	}

	prepareDefaultMakefile(project)
	{
		let content = "# Generated by cpp-build\n";
		content += `CPP=${this.cppCompilerCmd}\n`;
		content += `CC=${this.cCompilerCmd}\n`;

		// Include directories:
		content += "PROJECT_INCLUDE_DIRECTORIES="
		if (Array.isArray(project.includeDirectories))
		{
			const fmt = (dir) => GNUMakeGenerator.formatIncludeDirectory(project.__scriptDirectory, dir);
			content += project.includeDirectories.map( fmt ).join(" ");
		}
		content += "\n";
		
		// Linker directories:
		content += "PROJECT_LINKER_DIRECTORIES="
		if (Array.isArray(project.linkerDirectories))
		{
			const fmt = (dir) => GNUMakeGenerator.formatLinkerDirectory(project.__scriptDirectory, dir);
			content += project.linkerDirectories.map( fmt ).join(" ");
		}
		content += "\n";

		// Linked libraries:
		content += "PROJECT_LINKED_LIBRARIES="
		if (Array.isArray(project.linkedLibraries))
		{
			const fmt = (dir) => GNUMakeGenerator.formatLinkedLibrary(dir);
			content += project.linkedLibraries.map( fmt ).join(" ");
		}
		content += "\n";

		return content;
	}

	/**
	 * Generates GNU Makefile build info for specified target.
	 * @param {object|string} target - object or string (treated as filename)
	 */
	generate(target)
	{
		if (typeof target === "string")
		{
			let compilerString = null;
			
			{
				const compilerType = selectCompiler(target);

				if (compilerType == "cpp")
					compilerString = "$(CPP)";
				else if (compilerType == "c")
					compilerString = "$(CC)";
			}

			// Do not generate build steps for unsupported file types:
			if (!compilerString)
			{
				return null;
			}
			
			const targetAbsolutePath = path.resolve(this.workingDirectory, target);
			const targetBaseName = path.basename(target);

			// Create build step
			// TODO: add include folders, etc.
			return { 
					type: "step",
					stepName: targetBaseName,
					content: `${compilerString} -o ${targetBaseName}.o -c ${targetAbsolutePath} ${this.fileTargetOptions}`
				};
		}
		else if (typeof target === "object")
		{
			if (target.type === "application")
			{
				// 
				const makefilePrefix = this.prepareDefaultMakefile(target);

				let substepsContent = "";

				const buildAllStep = {
					header: "all:",
					command: `\t$(CPP) -o ${target.name||"a"} ${this.projectTargetOptions}`
				};
				for(const f of target.files)
				{
					const fGen = this.generate(f);
					if (fGen)
					{
						buildAllStep.header += " " + fGen.stepName;
						buildAllStep.command += " " + fGen.stepName + ".o";
						substepsContent += `\n${fGen.stepName}:\n\t${fGen.content}`;
					}
				}
				

				return {
					type: "makefile",
					content: `${makefilePrefix}\n\n${buildAllStep.header}\n${buildAllStep.command}\n\n${substepsContent}`
				};
			}
			else
			{
				throw `invalid target type: "${target.type || "unknown"}"`;
			}
		}
	}
}

module.exports = {
	GNUMakeGenerator
}